// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

window.deferred = (function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'undefined' ? null : require;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, i, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"d": {
		"index.js": function (exports, module, require) {
			'use strict';

			var assign        = require('es5-ext/object/assign')
			  , normalizeOpts = require('es5-ext/object/normalize-options')
			  , isCallable    = require('es5-ext/object/is-callable')
			  , contains      = require('es5-ext/string/#/contains')

			  , d;

			d = module.exports = function (dscr, value/*, options*/) {
				var c, e, w, options, desc;
				if ((arguments.length < 2) || (typeof dscr !== 'string')) {
					options = value;
					value = dscr;
					dscr = null;
				} else {
					options = arguments[2];
				}
				if (dscr == null) {
					c = w = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
					w = contains.call(dscr, 'w');
				}

				desc = { value: value, configurable: c, enumerable: e, writable: w };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};

			d.gs = function (dscr, get, set/*, options*/) {
				var c, e, options, desc;
				if (typeof dscr !== 'string') {
					options = set;
					set = get;
					get = dscr;
					dscr = null;
				} else {
					options = arguments[3];
				}
				if (get == null) {
					get = undefined;
				} else if (!isCallable(get)) {
					options = get;
					get = set = undefined;
				} else if (set == null) {
					set = undefined;
				} else if (!isCallable(set)) {
					options = set;
					set = undefined;
				}
				if (dscr == null) {
					c = true;
					e = false;
				} else {
					c = contains.call(dscr, 'c');
					e = contains.call(dscr, 'e');
				}

				desc = { get: get, set: set, configurable: c, enumerable: e };
				return !options ? desc : assign(normalizeOpts(options), desc);
			};
		}
	},
	"deferred": {
		"_ext.js": function (exports, module, require) {
			'use strict';
			
			var callable   = require('es5-ext/object/valid-callable')
			  , d          = require('d')
			  , isCallable = require('es5-ext/object/is-callable')
			  , ee         = require('event-emitter')
			  , isPromise  = require('./is-promise')
			
			  , create = Object.create, defineProperty = Object.defineProperty
			  , deferred, resolve, reject;
			
			module.exports = exports = function (name, unres, onres, res) {
				name = String(name);
				(callable(res) && ((onres == null) || callable(onres)) && callable(unres));
				defineProperty(exports._unresolved, name, d(unres));
				exports._onresolve[name] = onres;
				defineProperty(exports._resolved, name, d(res));
				exports._names.push(name);
			};
			
			exports._names = ['done', 'then', 'valueOf'];
			
			exports._unresolved = ee(create(Function.prototype, {
				then: d(function (win, fail) {
					var def;
					if (!this.pending) this.pending = [];
					def = deferred();
					this.pending.push('then', [win, fail, def.resolve, def.reject]);
					return def.promise;
				}),
				done: d(function (win, fail) {
					((win == null) || callable(win));
					((fail == null) || callable(fail));
					if (!this.pending) this.pending = [];
					this.pending.push('done', arguments);
				}),
				resolved: d(false),
				returnsPromise: d(true),
				valueOf: d(function () { return this; })
			}));
			
			exports._onresolve = {
				then: function (win, fail, resolve, reject) {
					var value, cb = this.failed ? fail : win;
					if (cb == null) {
						if (this.failed) reject(this.value);
						else resolve(this.value);
						return;
					}
					if (isCallable(cb)) {
						if (isPromise(cb)) {
							if (cb.resolved) {
								if (cb.failed) reject(cb.value);
								else resolve(cb.value);
								return;
							}
							cb.done(resolve, reject);
							return;
						}
						try { value = cb(this.value); } catch (e) {
							reject(e);
							return;
						}
						resolve(value);
						return;
					}
					resolve(cb);
				},
				done: function (win, fail) {
					if (this.failed) {
						if (fail) {
							fail(this.value);
							return;
						}
						throw this.value;
					}
					if (win) win(this.value);
				}
			};
			
			exports._resolved = ee(create(Function.prototype, {
				then: d(function (win, fail) {
					var value, cb = this.failed ? fail : win;
					if (cb == null) return this;
					if (isCallable(cb)) {
						if (isPromise(cb)) return cb;
						try { value = cb(this.value); } catch (e) { return reject(e); }
						return resolve(value);
					}
					return resolve(cb);
				}),
				done: d(function (win, fail) {
					((win == null) || callable(win));
					((fail == null) || callable(fail));
					if (this.failed) {
						if (fail) {
							fail(this.value);
							return;
						}
						throw this.value;
					}
					if (win) win(this.value);
				}),
				resolved: d(true),
				returnsPromise: d(true),
				valueOf: d(function () { return this.value; })
			}));
			
			deferred = require('./deferred');
			resolve = deferred.resolve;
			reject = deferred.reject;
			deferred.extend = exports;
		},
		"assimilate.js": function (exports, module, require) {
			// Assimilate eventual foreign promise
			
			'use strict';
			
			var isObject  = require('es5-ext/object/is-object')
			  , isPromise = require('./is-promise')
			  , deferred  = require('./deferred')
			  , nextTick  = require('next-tick')
			
			  , getPrototypeOf = Object.getPrototypeOf;
			
			module.exports = function self(value) {
				var then, done, def, resolve, reject;
				if (!value) return value;
				try {
					then = value.then;
				} catch (e) {
					return value;
				}
				if (typeof then !== 'function') return value;
				if (isPromise(value)) return value;
				if (!isObject(value)) return value;
				if (!getPrototypeOf(value)) return value;
				try {
					done = value.done;
				} catch (ignore) {}
				def = deferred();
				resolve = function (value) { def.resolve(self(value)); };
				reject = function (value) { def.reject(value); };
				if (typeof done === 'function') {
					try {
						done.call(value, resolve, reject);
					} catch (e) {
						return def.reject(e);
					}
					return def.promise;
				}
				try {
					then.call(value, function (value) { nextTick(function () {
						resolve(value);
					}); }, function (value) { nextTick(function () {
						reject(value);
					}); });
				} catch (e) {
					return def.reject(e);
				}
				return def.promise;
			};
		},
		"deferred.js": function (exports, module, require) {
			// Returns function that returns deferred or promise object.
			//
			// 1. If invoked without arguments then deferred object is returned
			//    Deferred object consist of promise (unresolved) function and resolve
			//    function through which we resolve promise
			// 2. If invoked with one argument then promise is returned which resolved value
			//    is given argument. Argument may be any value (even undefined),
			//    if it's promise then same promise is returned
			// 3. If invoked with more than one arguments then promise that resolves with
			//    array of all resolved arguments is returned.
			
			'use strict';
			
			var isError    = require('es5-ext/error/is-error')
			  , noop       = require('es5-ext/function/noop')
			  , isPromise  = require('./is-promise')
			
			  , every = Array.prototype.every, push = Array.prototype.push
			
			  , Deferred, createDeferred, count = 0, timeout, extendShim, ext
			  , protoSupported = Boolean(isPromise.__proto__)
			  , resolve, assimilate;
			
			extendShim = function (promise) {
				ext._names.forEach(function (name) {
					promise[name] = function () {
						return promise.__proto__[name].apply(promise, arguments);
					};
				});
				promise.returnsPromise = true;
				promise.resolved = promise.__proto__.resolved;
			};
			
			resolve = function (value, failed) {
				var promise = function (win, fail) { return promise.then(win, fail); };
				promise.value = value;
				promise.failed = failed;
				promise.__proto__ = ext._resolved;
				if (!protoSupported) { extendShim(promise); }
				if (createDeferred._profile) createDeferred._profile(true);
				return promise;
			};
			
			Deferred = function () {
				var promise = function (win, fail) { return promise.then(win, fail); };
				if (!count) timeout = setTimeout(noop, 1e9);
				++count;
				if (createDeferred._monitor) promise.monitor = createDeferred._monitor();
				promise.__proto__ = ext._unresolved;
				if (!protoSupported) extendShim(promise);
				(createDeferred._profile && createDeferred._profile());
				this.promise = promise;
				this.resolve = this.resolve.bind(this);
				this.reject = this.reject.bind(this);
			};
			
			Deferred.prototype = {
				resolved: false,
				_settle: function (value) {
					var i, name, data;
					this.promise.value = value;
					this.promise.__proto__ = ext._resolved;
					if (!protoSupported) this.promise.resolved = true;
					if (this.promise.dependencies) {
						this.promise.dependencies.forEach(function self(dPromise) {
							dPromise.value = value;
							dPromise.failed = this.failed;
							dPromise.__proto__ = ext._resolved;
							if (!protoSupported) dPromise.resolved = true;
							delete dPromise.pending;
							if (dPromise.dependencies) {
								dPromise.dependencies.forEach(self, this);
								delete dPromise.dependencies;
							}
						}, this.promise);
						delete this.promise.dependencies;
					}
					if ((data = this.promise.pending)) {
						for (i = 0; (name = data[i]); ++i) {
							ext._onresolve[name].apply(this.promise, data[++i]);
						}
						delete this.promise.pending;
					}
					return this.promise;
				},
				resolve: function (value) {
					if (this.resolved) return this.promise;
					this.resolved = true;
					if (!--count) clearTimeout(timeout);
					if (this.promise.monitor) clearTimeout(this.promise.monitor);
					value = assimilate(value);
					if (isPromise(value)) {
						if (!value.resolved) {
							if (!value.dependencies) {
								value.dependencies = [];
							}
							value.dependencies.push(this.promise);
							if (this.promise.pending) {
								if (value.pending) {
									push.apply(value.pending, this.promise.pending);
									this.promise.pending = value.pending;
									if (this.promise.dependencies) {
										this.promise.dependencies.forEach(function self(dPromise) {
											dPromise.pending = value.pending;
											if (dPromise.dependencies) {
												dPromise.dependencies.forEach(self);
											}
										});
									}
								} else {
									value.pending = this.promise.pending;
								}
							} else if (value.pending) {
								this.promise.pending = value.pending;
							} else {
								this.promise.pending = value.pending = [];
							}
							return this.promise;
						}
						this.promise.failed = value.failed;
						value = value.value;
					}
					return this._settle(value);
				},
				reject: function (error) {
					if (this.resolved) return this.promise;
					this.resolved = true;
					if (!--count) clearTimeout(timeout);
					if (this.promise.monitor) clearTimeout(this.promise.monitor);
					this.promise.failed = true;
					return this._settle(error);
				}
			};
			
			module.exports = createDeferred = function (value) {
				var l = arguments.length, d, waiting, initialized, result;
				if (!l) return new Deferred();
				if (l > 1) {
					d = new Deferred();
					waiting = 0;
					result = new Array(l);
					every.call(arguments, function (value, index) {
						value = assimilate(value);
						if (!isPromise(value)) {
							result[index] = value;
							return true;
						}
						if (value.resolved) {
							if (value.failed) {
								d.reject(value.value);
								return false;
							}
							result[index] = value.value;
							return true;
						}
						++waiting;
						value.done(function (value) {
							result[index] = value;
							if (!--waiting && initialized) d.resolve(result);
						}, d.reject);
						return true;
					});
					initialized = true;
					if (!waiting) d.resolve(result);
					return d.promise;
				}
				value = assimilate(value);
				if (isPromise(value)) return value;
				return resolve(value, isError(value));
			};
			
			createDeferred.Deferred = Deferred;
			createDeferred.reject = function (value) { return resolve(value, true); };
			createDeferred.resolve = function (value) {
				value = assimilate(value);
				if (isPromise(value)) return value;
				return resolve(value, false);
			};
			ext = require('./_ext');
			assimilate = require('./assimilate');
		},
		"ext": {
			"_process-arguments.js": function (exports, module, require) {
				'use strict';
				
				var arrayOf    = require('es5-ext/array/of')
				  , deferred   = require('../deferred')
				  , isPromise  = require('../is-promise')
				  , assimilate = require('../assimilate')
				
				  , push = Array.prototype.push, slice = Array.prototype.slice;
				
				module.exports = function (args, length) {
					var i, l, arg;
					if ((length != null) && (args.length !== length)) {
						args = slice.call(args, 0, length);
						if (args.length < length) {
							push.apply(args, new Array(length - args.length));
						}
					}
					for (i = 0, l = args.length; i < l; ++i) {
						arg = assimilate(args[i]);
						if (isPromise(arg)) {
							if (!arg.resolved) {
								if (l > 1) return deferred.apply(null, args);
								return arg(arrayOf);
							}
							if (arg.failed) return arg;
							args[i] = arg.value;
						}
					}
					return args;
				};
			},
			"array": {
				"map.js": function (exports, module, require) {
					// Promise aware Array's map
					
					'use strict';
					
					var assign     = require('es5-ext/object/assign')
					  , value      = require('es5-ext/object/valid-value')
					  , callable   = require('es5-ext/object/valid-callable')
					  , deferred   = require('../../deferred')
					  , isPromise  = require('../../is-promise')
					  , assimilate = require('../../assimilate')
					
					  , every = Array.prototype.every
					  , call = Function.prototype.call
					
					  , DMap;
					
					DMap = function (list, cb, context) {
						this.list = list;
						this.cb = cb;
						this.context = context;
						this.result = new Array(list.length >>> 0);
					
						assign(this, deferred());
						every.call(list, this.process, this);
						if (!this.waiting) return this.resolve(this.result);
						this.initialized = true;
					
						return this.promise;
					};
					
					DMap.prototype = {
						waiting: 0,
						initialized: false,
						process: function (value, index) {
							++this.waiting;
							value = assimilate(value);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(this.processCb.bind(this, index), this.reject);
									return true;
								}
								if (value.failed) {
									this.reject(value.value);
									return false;
								}
								value = value.value;
							}
							return this.processCb(index, value);
						},
						processCb: function (index, value) {
							if (this.promise.resolved) return false;
							if (this.cb) {
								try {
									value = call.call(this.cb, this.context, value, index, this.list);
								} catch (e) {
									this.reject(e);
									return false;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(this.processValue.bind(this, index), this.reject);
										return true;
									}
									if (value.failed) {
										this.reject(value.value);
										return false;
									}
									value = value.value;
								}
							}
							this.processValue(index, value);
							return true;
						},
						processValue: function (index, value) {
							if (this.promise.resolved) return;
							this.result[index] = value;
							if (!--this.waiting && this.initialized) this.resolve(this.result);
						}
					};
					
					module.exports = function (cb/*, thisArg*/) {
						value(this);
						((cb == null) || callable(cb));
					
						return new DMap(this, cb, arguments[1]);
					};
				},
				"reduce.js": function (exports, module, require) {
					// Promise aware Array's reduce
					
					'use strict';
					
					var assign     = require('es5-ext/object/assign')
					  , value      = require('es5-ext/object/valid-value')
					  , callable   = require('es5-ext/object/valid-callable')
					  , deferred   = require('../../deferred')
					  , isPromise  = require('../../is-promise')
					  , assimilate = require('../../assimilate')
					
					  , call = Function.prototype.call
					  , hasOwnProperty = Object.prototype.hasOwnProperty
					  , resolve = deferred.resolve
					  , Reduce;
					
					Reduce = function (list, cb, initial, initialized) {
						this.list = list;
						this.cb = cb;
						this.initialized = initialized;
						this.length = list.length >>> 0;
					
						initial = assimilate(initial);
						if (isPromise(initial)) {
							if (!initial.resolved) {
								assign(this, deferred());
								initial.done(function (initial) {
									this.value = initial;
									this.init();
								}.bind(this), this.reject);
								return this.promise;
							}
							this.value = initial.value;
							if (initial.failed) return initial;
						} else {
							this.value = initial;
						}
					
						return this.init();
					};
					
					Reduce.prototype = {
						current: 0,
						state: false,
						init: function () {
							while (this.current < this.length) {
								if (hasOwnProperty.call(this.list, this.current)) break;
								++this.current;
							}
							if (this.current === this.length) {
								if (!this.initialized) {
									throw new Error("Reduce of empty array with no initial value");
								}
								return this.resolve ? this.resolve(this.value) : resolve(this.value);
							}
							if (!this.promise) assign(this, deferred());
							this.processCb = this.processCb.bind(this);
							this.processValue = this.processValue.bind(this);
							this.continue();
							return this.promise;
						},
						continue: function () {
							var result;
							while (!this.state) {
								result = this.process();
								if (this.state !== 'cb') break;
								result = this.processCb(result);
								if (this.state !== 'value') break;
								this.processValue(result);
							}
						},
						process: function () {
							var value = assimilate(this.list[this.current]);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(function (result) {
										result = this.processCb(result);
										if (this.state !== 'value') return;
										this.processValue(result);
										if (!this.state) this.continue();
									}.bind(this), this.reject);
									return;
								}
								if (value.failed) {
									this.reject(value.value);
									return;
								}
								value = value.value;
							}
							this.state = 'cb';
							return value;
						},
						processCb: function (value) {
							if (!this.initialized) {
								this.initialized = true;
								this.state = 'value';
								return value;
							}
							if (this.cb) {
								try {
									value = call.call(this.cb, undefined, this.value, value, this.current,
										this.list);
								} catch (e) {
									this.reject(e);
									return;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(function (result) {
											this.state = 'value';
											this.processValue(result);
											if (!this.state) this.continue();
										}.bind(this), this.reject);
										return;
									}
									if (value.failed) {
										this.reject(value.value);
										return;
									}
									value = value.value;
								}
							}
							this.state = 'value';
							return value;
						},
						processValue: function (value) {
							this.value = value;
							while (++this.current < this.length) {
								if (hasOwnProperty.call(this.list, this.current)) {
									this.state = false;
									return;
								}
							}
							this.resolve(this.value);
						}
					};
					
					module.exports = function (cb/*, initial*/) {
						value(this);
						((cb == null) || callable(cb));
					
						return new Reduce(this, cb, arguments[1], arguments.length > 1);
					};
				},
				"some.js": function (exports, module, require) {
					// Promise aware Array's some
					
					'use strict';
					
					var assign     = require('es5-ext/object/assign')
					  , value      = require('es5-ext/object/valid-value')
					  , callable   = require('es5-ext/object/valid-callable')
					  , deferred   = require('../../deferred')
					  , isPromise  = require('../../is-promise')
					  , assimilate = require('../../assimilate')
					
					  , call = Function.prototype.call
					  , resolve = deferred.resolve
					  , Some;
					
					Some = function (list, cb, context) {
						this.list = list;
						this.cb = cb;
						this.context = context;
						this.length = list.length >>> 0;
					
						while (this.current < this.length) {
							if (this.current in list) {
								assign(this, deferred());
								this.processCb = this.processCb.bind(this);
								this.processValue = this.processValue.bind(this);
								this.process();
								return this.promise;
							}
							++this.current;
						}
						return resolve(false);
					};
					
					Some.prototype = {
						current: 0,
						process: function () {
							var value = assimilate(this.list[this.current]);
							if (isPromise(value)) {
								if (!value.resolved) {
									value.done(this.processCb, this.reject);
									return;
								}
								if (value.failed) {
									this.reject(value.value);
									return;
								}
								value = value.value;
							}
							this.processCb(value);
						},
						processCb: function (value) {
							if (this.cb) {
								try {
									value = call.call(this.cb, this.context, value, this.current,
										this.list);
								} catch (e) {
									this.reject(e);
									return;
								}
								value = assimilate(value);
								if (isPromise(value)) {
									if (!value.resolved) {
										value.done(this.processValue, this.reject);
										return;
									}
									if (value.failed) {
										this.reject(value.value);
										return;
									}
									value = value.value;
								}
							}
							this.processValue(value);
						},
						processValue: function (value) {
							if (value) {
								this.resolve(true);
								return;
							}
							while (++this.current < this.length) {
								if (this.current in this.list) {
									this.process();
									return;
								}
							}
							this.resolve(false);
						}
					};
					
					module.exports = function (cb/*, thisArg*/) {
						value(this);
						((cb == null) || callable(cb));
					
						return new Some(this, cb, arguments[1]);
					};
				}
			},
			"function": {
				"call-async.js": function (exports, module, require) {
					// Call asynchronous function
					
					'use strict';
					
					var toArray          = require('es5-ext/array/to-array')
					  , callable         = require('es5-ext/object/valid-callable')
					  , deferred         = require('../../deferred')
					  , isPromise        = require('../../is-promise')
					  , processArguments = require('../_process-arguments')
					
					  , slice = Array.prototype.slice, apply = Function.prototype.apply
					
					  , applyFn, callAsync;
					
					applyFn = function (fn, args, def) {
						args = toArray(args);
						apply.call(fn,  this, args.concat(function (error, result) {
							if (error == null) {
								def.resolve((arguments.length > 2) ? slice.call(arguments, 1) : result);
							} else {
								def.reject(error);
							}
						}));
					};
					
					callAsync = function (fn, length, context, args) {
						var def;
						args = processArguments(args, length);
						if (isPromise(args)) {
							if (args.failed) return args;
							def = deferred();
							args.done(function (args) {
								if (fn.returnsPromise) return apply.call(fn, context, args);
								try {
									applyFn.call(context, fn, args, def);
								} catch (e) { def.reject(e); }
							}, def.reject);
							return def.promise;
						}
						if (fn.returnsPromise) return apply.call(fn, context, args);
						def = deferred();
						try {
							applyFn.call(context, fn, args, def);
						} catch (e) {
							def.reject(e);
							throw e;
						}
						return def.promise;
					};
					
					module.exports = exports = function (context/*, …args*/) {
						return callAsync(callable(this), null, context, slice.call(arguments, 1));
					};
					
					Object.defineProperty(exports, '_base', { configurable: true,
						enumerable: false, writable: true, value: callAsync });
				},
				"delay.js": function (exports, module, require) {
					// Delay function execution, return promise for delayed function result
					
					'use strict';
					
					var apply    = Function.prototype.apply
					  , callable = require('es5-ext/object/valid-callable')
					  , deferred = require('../../deferred')
					
					  , delayed;
					
					delayed = function (fn, args, resolve, reject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							reject(e);
							return;
						}
						resolve(value);
					};
					
					module.exports = function (timeout) {
						var fn, result;
						fn = callable(this);
						result = function () {
							var def = deferred();
							setTimeout(delayed.bind(this, fn, arguments, def.resolve, def.reject),
								timeout);
							return def.promise;
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"gate.js": function (exports, module, require) {
					// Limit number of concurrent function executions (to cLimit number).
					// Limited calls are queued. Optionaly maximum queue length can also be
					// controlled with qLimit value, any calls that would reach over that limit
					// would be discarded (its promise would resolve with "Too many calls" error)
					
					'use strict';
					
					var toPosInt   = require('es5-ext/number/to-pos-integer')
					  , callable   = require('es5-ext/object/valid-callable')
					  , eeUnify    = require('event-emitter/unify')
					  , deferred   = require('../../deferred')
					  , isPromise  = require('../../is-promise')
					  , assimilate = require('../../assimilate')
					
					  , resolve = deferred.resolve, reject = deferred.reject
					  , apply = Function.prototype.apply, max = Math.max
					  , gateReject;
					
					require('../promise/finally');
					
					gateReject = function () {
						var e = new Error("Too many calls");
						e.type = 'deferred-gate-rejected';
						return reject(e);
					};
					
					module.exports = function (cLimit, qLimit) {
						var fn, count, decrement, unload, queue, run, result;
						fn = callable(this);
						cLimit = max(toPosInt(cLimit), 1);
						qLimit = ((qLimit == null) || isNaN(qLimit)) ? Infinity : toPosInt(qLimit);
						count = 0;
						queue = [];
					
						run = function (thisArg, args, def) {
							var r;
							try {
								r = apply.call(fn, thisArg, args);
							} catch (e) {
								if (!def) return reject(e);
								def.reject(e);
								unload();
								return;
							}
							r = assimilate(r);
							if (isPromise(r)) {
								if (def) eeUnify(def.promise, r);
								if (!r.resolved) {
									++count;
									if (def) def.resolve(r);
									return r.finally(decrement);
								}
								r = r.value;
							}
							if (!def) return resolve(r);
							def.resolve(r);
							unload();
						};
					
						decrement = function () {
							--count;
							unload();
						};
					
						unload = function () {
							var data;
							if ((data = queue.shift())) run.apply(null, data);
						};
					
						result = function () {
							var def;
							if (count >= cLimit) {
								if (queue.length < qLimit) {
									def = deferred();
									queue.push([this, arguments, def]);
									return def.promise;
								}
								return gateReject();
							}
							return run(this, arguments);
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"promisify-sync.js": function (exports, module, require) {
					// Promisify synchronous function
					
					'use strict';
					
					var callable         = require('es5-ext/object/valid-callable')
					  , deferred         = require('../../deferred')
					  , isPromise        = require('../../is-promise')
					  , processArguments = require('../_process-arguments')
					
					  , apply = Function.prototype.apply
					
					  , applyFn;
					
					applyFn = function (fn, args, resolve, reject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							reject(e);
							return;
						}
						resolve(value);
					};
					
					module.exports = function (length) {
						var fn, result;
						fn = callable(this);
						if (fn.returnsPromise) return fn;
						if (length != null) length = length >>> 0;
						result = function () {
							var args, def;
							args = processArguments(arguments, length);
					
							if (isPromise(args)) {
								if (args.failed) return args;
								def = deferred();
								args.done(function (args) {
									applyFn.call(this, fn, args, def.resolve, def.reject);
								}.bind(this), def.reject);
							} else {
								def = deferred();
								applyFn.call(this, fn, args, def.resolve, def.reject);
							}
					
							return def.promise;
						};
						result.returnsPromise = true;
						return result;
					};
				},
				"promisify.js": function (exports, module, require) {
					// Promisify asynchronous function
					
					'use strict';
					
					var callable  = require('es5-ext/object/valid-callable')
					  , callAsync = require('./call-async')._base;
					
					module.exports = function (length) {
						var fn, result;
						fn = callable(this);
						if (fn.returnsPromise) return fn;
						if (length != null) length = length >>> 0;
						result = function () { return callAsync(fn, length, this, arguments); };
						result.returnsPromise = true;
						return result;
					};
				}
			},
			"promise": {
				"_array.js": function (exports, module, require) {
					// Used by promise extensions that are based on array extensions.
					
					'use strict';
					
					var callable = require('es5-ext/object/valid-callable')
					  , deferred = require('../../deferred')
					
					  , reject = deferred.reject;
					
					module.exports = function (name, ext) {
						deferred.extend(name, function (cb) {
							var def;
							((cb == null) || callable(cb));
							if (!this.pending) this.pending = [];
							def = deferred();
							this.pending.push(name, [arguments, def.resolve, def.reject]);
							return def.promise;
						}, function (args, resolve, reject) {
							var result;
							if (this.failed) {
								reject(this.value);
								return;
							}
							try {
								result = ext.apply(this.value, args);
							} catch (e) {
								reject(e);
								return;
							}
							resolve(result);
						}, function (cb) {
							((cb == null) || callable(cb));
							if (this.failed) return this;
							try {
								return ext.apply(this.value, arguments);
							} catch (e) {
								return reject(e);
							}
						});
					};
				},
				"aside.js": function (exports, module, require) {
					// 'aside' - Promise extension
					//
					// promise.aside(win, fail)
					//
					// Works in analogous way as promise function itself (or `then`)
					// but instead of adding promise to promise chain it returns context promise and
					// lets callback carry on with other processing logic
					
					'use strict';
					
					var callable = require('es5-ext/object/valid-callable')
					  , deferred = require('../../deferred');
					
					deferred.extend('aside', function (win, fail) {
						((win == null) || callable(win));
						((fail == null) || callable(fail));
						if (win || fail) {
							if (!this.pending) {
								this.pending = [];
							}
							this.pending.push('aside', arguments);
						}
						return this;
					}, function (win, fail) {
						var cb = this.failed ? fail : win;
						if (cb) {
							cb(this.value);
						}
					}, function (win, fail) {
						var cb;
						((win == null) || callable(win));
						((fail == null) || callable(fail));
						cb = this.failed ? fail : win;
						if (cb) {
							cb(this.value);
						}
						return this;
					});
				},
				"catch.js": function (exports, module, require) {
					// 'catch' - Promise extension
					//
					// promise.catch(cb)
					//
					// Same as `then` but accepts only onFail callback
					
					'use strict';
					
					var isCallable = require('es5-ext/object/is-callable')
					  , validValue = require('es5-ext/object/valid-value')
					  , deferred   = require('../../deferred')
					  , isPromise  = require('../../is-promise')
					
					  , resolve = deferred.resolve, reject = deferred.reject;
					
					deferred.extend('catch', function (cb) {
						var def;
						validValue(cb);
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('catch', [cb, def.resolve, def.reject]);
						return def.promise;
					}, function (cb, resolve, reject) {
						var value;
						if (!this.failed) {
							resolve(this.value);
							return;
						}
						if (isCallable(cb)) {
							if (isPromise(cb)) {
								if (cb.resolved) {
									if (cb.failed) reject(cb.value);
									else resolve(cb.value);
								} else {
									cb.done(resolve, reject);
								}
								return;
							}
							try { value = cb(this.value); } catch (e) {
								reject(e);
								return;
							}
							resolve(value);
							return;
						}
						resolve(cb);
					}, function (cb) {
						var value;
						validValue(cb);
						if (!this.failed) return this;
						if (isCallable(cb)) {
							if (isPromise(cb)) return cb;
							try { value = cb(this.value); } catch (e) {
								return reject(e);
							}
							return resolve(value);
						}
						return resolve(cb);
					});
				},
				"cb.js": function (exports, module, require) {
					// 'cb' - Promise extension
					//
					// promise.cb(cb)
					//
					// Handles asynchronous function style callback (which is run in next event loop
					// the earliest). Returns self promise. Callback is optional.
					//
					// Useful when we want to configure typical asynchronous function which logic is
					// internally configured with promises.
					//
					// Extension can be used as follows:
					//
					// var foo = function (arg1, arg2, cb) {
					//     var d = deferred();
					//     // ... implementation
					//     return d.promise.cb(cb);
					// };
					//
					// `cb` extension returns promise and handles eventual callback (optional)
					
					'use strict';
					
					var callable   = require('es5-ext/object/valid-callable')
					  , nextTick   = require('next-tick')
					  , deferred   = require('../../deferred');
					
					deferred.extend('cb', function (cb) {
						if (cb == null) return this;
						callable(cb);
						nextTick(function () {
							if (this.resolved) {
								if (this.failed) cb(this.value);
								else cb(null, this.value);
							} else {
								if (!this.pending) this.pending = [];
								this.pending.push('cb', [cb]);
							}
						}.bind(this));
						return this;
					}, function (cb) {
						if (this.failed) cb(this.value);
						else cb(null, this.value);
					}, function (cb) {
						if (cb == null) return this;
						callable(cb);
						nextTick(function () {
							if (this.failed) cb(this.value);
							else cb(null, this.value);
						}.bind(this));
						return this;
					});
				},
				"finally.js": function (exports, module, require) {
					// 'finally' - Promise extension
					//
					// promise.finally(cb)
					//
					// Called on promise resolution returns same promise, doesn't pass any values to
					// provided callback
					
					'use strict';
					
					var callable = require('es5-ext/object/valid-callable')
					  , deferred = require('../../deferred');
					
					deferred.extend('finally', function (cb) {
						callable(cb);
						if (!this.pending) this.pending = [];
						this.pending.push('finally', arguments);
						return this;
					}, function (cb) { cb(); }, function (cb) {
						callable(cb)();
						return this;
					});
				},
				"get.js": function (exports, module, require) {
					// 'get' - Promise extension
					//
					// promise.get(name)
					//
					// Resolves with property of resolved object
					
					'use strict';
					
					var value    = require('es5-ext/object/valid-value')
					  , deferred = require('../../deferred')
					
					  , reduce = Array.prototype.reduce
					  , resolve = deferred.resolve, reject = deferred.reject;
					
					deferred.extend('get', function (/*…name*/) {
						var def;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('get', [arguments, def.resolve, def.reject]);
						return def.promise;
					
					}, function (args, resolve, reject) {
						var result;
						if (this.failed) reject(this.value);
						try {
							result = reduce.call(args, function (obj, key) {
								return value(obj)[String(key)];
							}, this.value);
						} catch (e) {
							reject(e);
							return;
						}
						resolve(result);
					}, function (/*…name*/) {
						var result;
						if (this.failed) return this;
						try {
							result = reduce.call(arguments, function (obj, key) {
								return value(obj)[String(key)];
							}, this.value);
						} catch (e) {
							return reject(e);
						}
						return resolve(result);
					});
				},
				"invoke-async.js": function (exports, module, require) {
					// 'invokeAsync' - Promise extension
					//
					// promise.invokeAsync(name[, arg0[, arg1[, ...]]])
					//
					// On resolved object calls asynchronous method that takes callback
					// (Node.js style).
					// Do not pass callback, it's handled by internal implementation.
					// 'name' can be method name or method itself.
					
					'use strict';
					
					var toArray          = require('es5-ext/array/to-array')
					  , isCallable       = require('es5-ext/object/is-callable')
					  , deferred         = require('../../deferred')
					  , isPromise        = require('../../is-promise')
					  , processArguments = require('../_process-arguments')
					
					  , slice = Array.prototype.slice, apply = Function.prototype.apply
					  , reject = deferred.reject
					
					  , applyFn;
					
					applyFn = function (fn, args, resolve, reject) {
						var result;
						if (fn.returnsPromise) {
							try {
								result = apply.call(fn, this, args);
							} catch (e) {
								reject(e);
								return;
							}
							return resolve(result);
						}
						args = toArray(args).concat(function (error, result) {
							if (error == null) {
								resolve((arguments.length > 2) ? slice.call(arguments, 1) : result);
							} else {
								reject(error);
							}
						});
						try {
							apply.call(fn, this, args);
						} catch (e2) {
							reject(e2);
						}
					};
					
					deferred.extend('invokeAsync', function (method/*, …args*/) {
						var def;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('invokeAsync', [arguments, def.resolve, def.reject]);
						return def.promise;
					}, function (args, resolve, reject) {
						var fn;
						if (this.failed) {
							reject(this.value);
							return;
						}
					
						if (this.value == null) {
							reject(new TypeError("Cannot use null or undefined"));
							return;
						}
					
						fn = args[0];
						if (!isCallable(fn)) {
							fn = String(fn);
							if (!isCallable(this.value[fn])) {
								reject(new TypeError(fn + " is not a function"));
								return;
							}
							fn = this.value[fn];
						}
					
						args = processArguments(slice.call(args, 1));
						if (isPromise(args)) {
							if (args.failed) {
								reject(args.value);
								return;
							}
							args.done(function (args) {
								applyFn.call(this, fn, args, resolve, reject);
							}.bind(this.value), reject);
						} else {
							applyFn.call(this.value, fn, args, resolve, reject);
						}
					}, function (method/*, …args*/) {
						var args, def;
						if (this.failed) return this;
					
						if (this.value == null) {
							return reject(new TypeError("Cannot use null or undefined"));
						}
					
						if (!isCallable(method)) {
							method = String(method);
							if (!isCallable(this.value[method])) {
								return reject(new TypeError(method + " is not a function"));
							}
							method = this.value[method];
						}
					
						args = processArguments(slice.call(arguments, 1));
						if (isPromise(args)) {
							if (args.failed) return args;
							def = deferred();
							args.done(function (args) {
								applyFn.call(this, method, args, def.resolve, def.reject);
							}.bind(this.value), def.reject);
						} else if (!method.returnsPromise) {
							def = deferred();
							applyFn.call(this.value, method, args, def.resolve, def.reject);
						} else {
							return applyFn.call(this.value, method, args, deferred, reject);
						}
						return def.promise;
					});
				},
				"invoke.js": function (exports, module, require) {
					// 'invoke' - Promise extension
					//
					// promise.invoke(name[, arg0[, arg1[, ...]]])
					//
					// On resolved object calls method that returns immediately.
					// 'name' can be method name or method itself.
					
					'use strict';
					
					var isCallable       = require('es5-ext/object/is-callable')
					  , deferred         = require('../../deferred')
					  , isPromise        = require('../../is-promise')
					  , processArguments = require('../_process-arguments')
					
					  , slice = Array.prototype.slice, apply = Function.prototype.apply
					  , reject = deferred.reject
					  , applyFn;
					
					applyFn = function (fn, args, resolve, reject) {
						var value;
						try {
							value = apply.call(fn, this, args);
						} catch (e) {
							return reject(e);
						}
						return resolve(value);
					};
					
					deferred.extend('invoke', function (method/*, …args*/) {
						var def;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('invoke', [arguments, def.resolve, def.reject]);
						return def.promise;
					}, function (args, resolve, reject) {
						var fn;
						if (this.failed) {
							reject(this.value);
							return;
						}
					
						if (this.value == null) {
							reject(new TypeError("Cannot use null or undefined"));
							return;
						}
					
						fn = args[0];
						if (!isCallable(fn)) {
							fn = String(fn);
							if (!isCallable(this.value[fn])) {
								reject(new TypeError(fn + " is not a function"));
								return;
							}
							fn = this.value[fn];
						}
					
						args = processArguments(slice.call(args, 1));
						if (isPromise(args)) {
							if (args.failed) {
								reject(args.value);
								return;
							}
							args.done(function (args) {
								applyFn.call(this, fn, args, resolve, reject);
							}.bind(this.value), reject);
						} else {
							applyFn.call(this.value, fn, args, resolve, reject);
						}
					}, function (method/*, …args*/) {
						var args, def;
						if (this.failed) return this;
					
						if (this.value == null) {
							return reject(new TypeError("Cannot use null or undefined"));
						}
					
						if (!isCallable(method)) {
							method = String(method);
							if (!isCallable(this.value[method])) {
								return reject(new TypeError(method + " is not a function"));
							}
							method = this.value[method];
						}
					
						args = processArguments(slice.call(arguments, 1));
						if (isPromise(args)) {
							if (args.failed) return args;
							def = deferred();
							args.done(function (args) {
								applyFn.call(this, method, args, def.resolve, def.reject);
							}.bind(this.value), def.reject);
							return def.promise;
						}
						return applyFn.call(this.value, method, args, deferred, reject);
					});
				},
				"map.js": function (exports, module, require) {
					// 'map' - Promise extension
					//
					// promise.map(fn[, thisArg[, concurrentLimit]])
					//
					// Promise aware map for array-like results
					
					'use strict';
					
					require('./_array')('map', require('../array/map'));
				},
				"reduce.js": function (exports, module, require) {
					// 'reduce' - Promise extension
					//
					// promise.reduce(fn[, initial])
					//
					// Promise aware reduce for array-like results
					
					'use strict';
					
					require('./_array')('reduce', require('../array/reduce'));
				},
				"some.js": function (exports, module, require) {
					// 'some' - Promise extension
					//
					// promise.some(fn[, thisArg])
					//
					// Promise aware some for array-like results
					
					'use strict';
					
					require('./_array')('some', require('../array/some'));
				},
				"spread.js": function (exports, module, require) {
					// 'spread' - Promise extensions
					//
					// promise.spread(onsuccess, onerror)
					//
					// Matches eventual list result onto function arguments,
					// otherwise works same as 'then' (promise function itself)
					
					'use strict';
					
					var spread     = require('es5-ext/function/#/spread')
					  , callable   = require('es5-ext/object/valid-callable')
					  , isCallable = require('es5-ext/object/is-callable')
					  , isPromise  = require('../../is-promise')
					  , deferred   = require('../../deferred')
					
					  , resolve = deferred.resolve, reject = deferred.reject;
					
					deferred.extend('spread', function (win, fail) {
						var def;
						((win == null) || callable(win));
						if (!win && (fail == null)) return this;
						if (!this.pending) this.pending = [];
						def = deferred();
						this.pending.push('spread', [win, fail, def.resolve, def.reject]);
						return def.promise;
					}, function (win, fail, resolve, reject) {
						var cb, value;
						cb = this.failed ? fail : win;
						if (cb == null) {
							if (this.failed) reject(this.value);
							else resolve(this.value);
						}
						if (isCallable(cb)) {
							if (isPromise(cb)) {
								if (cb.resolved) {
									if (cb.failed) reject(cb.value);
									else resolve(cb.value);
								} else {
									cb.done(resolve, reject);
								}
								return;
							}
							if (!this.failed) cb = spread.call(cb);
							try {
								value = cb(this.value);
							} catch (e) {
								reject(e);
								return;
							}
							resolve(value);
						} else {
							resolve(cb);
						}
					}, function (win, fail) {
						var cb, value;
						cb = this.failed ? fail : win;
						if (cb == null) return this;
						if (isCallable(cb)) {
							if (isPromise(cb)) return cb;
							if (!this.failed) cb = spread.call(cb);
							try {
								value = cb(this.value);
							} catch (e) {
								return reject(e);
							}
							return resolve(value);
						}
						return resolve(cb);
					});
				}
			}
		},
		"index.js": function (exports, module, require) {
			// This construct deferred with all needed goodies that are being exported
			// when we import 'deferred' by main name.
			// All available promise extensions are also initialized.
			
			'use strict';
			
			var call   = Function.prototype.call
			  , assign = require('es5-ext/object/assign');
			
			module.exports = assign(require('./deferred'), {
				invokeAsync:   require('./invoke-async'),
				isPromise:     require('./is-promise'),
				validPromise:  require('./valid-promise'),
				callAsync:     call.bind(require('./ext/function/call-async')),
				delay:         call.bind(require('./ext/function/delay')),
				gate:          call.bind(require('./ext/function/gate')),
				monitor:       require('./monitor'),
				promisify:     call.bind(require('./ext/function/promisify')),
				promisifySync: call.bind(require('./ext/function/promisify-sync')),
				map:           call.bind(require('./ext/array/map')),
				reduce:        call.bind(require('./ext/array/reduce')),
				some:          call.bind(require('./ext/array/some'))
			}, require('./profiler'));
			
			require('./ext/promise/aside');
			require('./ext/promise/catch');
			require('./ext/promise/cb');
			require('./ext/promise/finally');
			require('./ext/promise/get');
			require('./ext/promise/invoke');
			require('./ext/promise/invoke-async');
			require('./ext/promise/map');
			require('./ext/promise/spread');
			require('./ext/promise/some');
			require('./ext/promise/reduce');
		},
		"invoke-async.js": function (exports, module, require) {
			// Invoke asynchronous function
			
			'use strict';
			
			var isCallable = require('es5-ext/object/is-callable')
			  , callable   = require('es5-ext/object/valid-callable')
			  , value      = require('es5-ext/object/valid-value')
			  , callAsync  = require('./ext/function/call-async')._base
			
			  , slice = Array.prototype.slice;
			
			module.exports = function (obj, fn/*, …args*/) {
				value(obj);
				if (!isCallable(fn)) fn = callable(obj[fn]);
				return callAsync(fn, null, obj, slice.call(arguments, 2));
			};
		},
		"is-promise.js": function (exports, module, require) {
			// Whether given object is a promise
			
			'use strict';
			
			module.exports = function (o) {
				return (typeof o === 'function') && (typeof o.then === 'function');
			};
		},
		"monitor.js": function (exports, module, require) {
			// Run if you want to monitor unresolved promises (in properly working
			// application there should be no promises that are never resolved)
			
			'use strict';
			
			var max        = Math.max
			  , callable   = require('es5-ext/object/valid-callable')
			  , isCallable = require('es5-ext/object/is-callable')
			  , toPosInt   = require('es5-ext/number/to-pos-integer')
			  , deferred   = require('./deferred');
			
			exports = module.exports = function (timeout, cb) {
				if (timeout === false) {
					// Cancel monitor
					delete deferred._monitor;
					delete exports.timeout;
					delete exports.callback;
					return;
				}
				exports.timeout = timeout = max(toPosInt(timeout) || 5000, 50);
				if (cb == null) {
					if ((typeof console !== 'undefined') && console &&
							isCallable(console.error)) {
						cb = function (e) {
							console.error(((e.stack && e.stack.toString()) ||
								"Unresolved promise: no stack available"));
						};
					}
				} else {
					callable(cb);
				}
				exports.callback = cb;
			
				deferred._monitor = function () {
					var e = new Error("Unresolved promise");
					return setTimeout(function () {
						if (cb) cb(e);
					}, timeout);
				};
			};
		},
		"profiler.js": function (exports, module, require) {
			'use strict';
			
			var partial  = require('es5-ext/function/#/partial')
			  , forEach  = require('es5-ext/object/for-each')
			  , pad      = require('es5-ext/string/#/pad')
			  , deferred = require('./deferred')
			
			  , resolved, rStats, unresolved, uStats, profile;
			
			exports.profile = function () {
				resolved = 0;
				rStats = {};
				unresolved = 0;
				uStats = {};
				deferred._profile = profile;
			};
			
			profile = function (isResolved) {
				var stack, data;
			
				if (isResolved) {
					++resolved;
					data = rStats;
				} else {
					++unresolved;
					data = uStats;
				}
			
				stack = (new Error()).stack;
				if (!stack.split('\n').slice(3).some(function (line) {
						if ((line.search(/[\/\\]deferred[\/\\]/) === -1) &&
								(line.search(/[\/\\]es5-ext[\/\\]/) === -1) &&
								(line.indexOf(' (native)') === -1)) {
							line = line.replace(/\n/g, "\\n").trim();
							if (!data[line]) {
								data[line] = { count: 0 };
							}
							++data[line].count;
							return true;
						}
					})) {
					if (!data.unknown) {
						data.unknown = { count: 0, stack: stack };
					}
					++data.unknown.count;
				}
			};
			
			exports.profileEnd = function () {
				var total, lpad, log = '';
			
				if (!deferred._profile) {
					throw new Error("Deferred profiler was not initialized");
				}
				delete deferred._profile;
			
				log += "------------------------------------------------------------\n";
				log += "Deferred usage statistics:\n\n";
			
				total = String(resolved + unresolved);
				lpad = partial.call(pad, " ", total.length);
				log += total + " Total promises initialized\n";
				log += lpad.call(unresolved) + " Initialized as Unresolved\n";
				log += lpad.call(resolved) + " Initialized as Resolved\n";
			
				if (unresolved) {
					log += "\nUnresolved promises were initialized at:\n";
					forEach(uStats, function (data, name) {
						log += lpad.call(data.count) + " " + name + "\n";
					}, null, function (a, b) {
						return this[b].count - this[a].count;
					});
				}
			
				if (resolved) {
					log += "\nResolved promises were initialized at:\n";
					forEach(rStats, function (data, name) {
						log += lpad.call(data.count) + " " + name + "\n";
					}, null, function (a, b) {
						return this[b].count - this[a].count;
					});
				}
				log += "------------------------------------------------------------\n";
			
				return {
					log: log,
					resolved: { count: resolved, stats: rStats },
					unresolved: { count: unresolved, stats: uStats }
				};
			};
		},
		"valid-promise.js": function (exports, module, require) {
			'use strict';
			
			var isPromise = require('./is-promise');
			
			module.exports = function (x) {
				if (!isPromise(x)) {
					throw new TypeError(x + " is not a promise object");
				}
				return x;
			};
		}
	},
	"es5-ext": {
		"array": {
			"from": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Array.from
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						var from = Array.from, arr, result;
						if (typeof from !== 'function') return false;
						arr = ['raz', 'dwa'];
						result = from(arr);
						return Boolean(result && (result !== arr) && (result[1] === 'dwa'));
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var iteratorSymbol = require('es6-symbol').iterator
					  , isArguments    = require('../../function/is-arguments')
					  , isFunction     = require('../../function/is-function')
					  , toPosInt       = require('../../number/to-pos-integer')
					  , callable       = require('../../object/valid-callable')
					  , validValue     = require('../../object/valid-value')
					  , isString       = require('../../string/is-string')

					  , isArray = Array.isArray, call = Function.prototype.call
					  , desc = { configurable: true, enumerable: true, writable: true, value: null }
					  , defineProperty = Object.defineProperty;

					module.exports = function (arrayLike/*, mapFn, thisArg*/) {
						var mapFn = arguments[1], thisArg = arguments[2], Constructor, i, j, arr, l, code, iterator
						  , result, getIterator, isPlain, value;

						arrayLike = Object(validValue(arrayLike));

						if (mapFn != null) callable(mapFn);
						if (!this || (this === Array) || !isFunction(this)) {
							// Result: Plain array
							if (!mapFn) {
								if (isArguments(arrayLike)) {
									// Source: Arguments
									l = arrayLike.length;
									if (l !== 1) return Array.apply(null, arrayLike);
									arr = new Array(1);
									arr[0] = arrayLike[0];
									return arr;
								}
								if (isArray(arrayLike)) {
									// Source: Array
									arr = new Array(l = arrayLike.length);
									for (i = 0; i < l; ++i) arr[i] = arrayLike[i];
									return arr;
								}
							}
							arr = [];
						} else {
							// Result: Non plain array
							Constructor = this;
						}

						if (!isArray(arrayLike)) {
							if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
								// Source: Iterator
								iterator = callable(getIterator).call(arrayLike);
								if (Constructor) arr = new Constructor();
								result = iterator.next();
								i = 0;
								while (!result.done) {
									value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
									if (!Constructor) {
										arr[i] = value
									} else {
										desc.value = value;
										defineProperty(arr, i, desc);
									}
									result = iterator.next();
									++i;
								}
								l = i;
							} else if (isString(arrayLike)) {
								// Source: String
								l = arrayLike.length;
								if (Constructor) arr = new Constructor();
								for (i = 0, j = 0; i < l; ++i) {
									value = arrayLike[i];
									if ((i + 1) < l) {
										code = value.charCodeAt(0);
										if ((code >= 0xD800) && (code <= 0xDBFF)) value += arrayLike[++i];
									}
									value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
									if (!Constructor) {
										arr[j] = value
									} else {
										desc.value = value;
										defineProperty(arr, j, desc);
									}
									++j;
								}
								l = j;
							}
						}
						if (l === undefined) {
							// Source: array or array-like
							l = toPosInt(arrayLike.length);
							if (Constructor) arr = new Constructor(l);
							for (i = 0; i < l; ++i) {
								value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
								if (!Constructor) {
									arr[i] = value
								} else {
									desc.value = value;
									defineProperty(arr, i, desc);
								}
							}
						}
						if (Constructor) {
							desc.value = null;
							arr.length = l;
						}
						return arr;
					};
				}
			},
			"of": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Array.of
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						var of = Array.of, result;
						if (typeof of !== 'function') return false;
						result = of('foo', 'bar');
						return Boolean(result && (result[1] === 'bar'));
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var isFunction = require('../../function/is-function')

					  , slice = Array.prototype.slice, defineProperty = Object.defineProperty
					  , desc = { configurable: true, enumerable: true, writable: true, value: null };

					module.exports = function (/*…items*/) {
						var result, i, l;
						if (!this || (this === Array) || !isFunction(this)) return slice.call(arguments);
						result = new this(l = arguments.length);
						for (i = 0; i < l; ++i) {
							desc.value = arguments[i];
							defineProperty(result, i, desc);
						}
						desc.value = null;
						result.length = l;
						return result;
					};
				}
			},
			"to-array.js": function (exports, module, require) {
				'use strict';

				var from = require('./from')

				  , isArray = Array.isArray;

				module.exports = function (arrayLike) {
					return isArray(arrayLike) ? arrayLike : from(arrayLike);
				};
			}
		},
		"error": {
			"is-error.js": function (exports, module, require) {
				'use strict';

				var toString = Object.prototype.toString

				  , id = toString.call(new Error());

				module.exports = function (x) {
					return (x && ((x instanceof Error) || (toString.call(x)) === id)) || false;
				};
			}
		},
		"function": {
			"#": {
				"partial.js": function (exports, module, require) {
					'use strict';

					var callable     = require('../../object/valid-callable')
					  , aFrom        = require('../../array/from')
					  , defineLength = require('../_define-length')

					  , apply = Function.prototype.apply;

					module.exports = function (/*…args*/) {
						var fn = callable(this)
						  , args = aFrom(arguments);

						return defineLength(function () {
							return apply.call(fn, this, args.concat(aFrom(arguments)));
						}, fn.length - args.length);
					};
				},
				"spread.js": function (exports, module, require) {
					'use strict';

					var callable = require('../../object/valid-callable')

					  , apply = Function.prototype.apply;

					module.exports = function () {
						var fn = callable(this);
						return function (args) { return apply.call(fn, this, args); };
					};
				}
			},
			"_define-length.js": function (exports, module, require) {
				'use strict';

				var toPosInt = require('../number/to-pos-integer')

				  , test = function (a, b) {}, desc, defineProperty
				  , generate, mixin;

				try {
					Object.defineProperty(test, 'length', { configurable: true, writable: false,
						enumerable: false, value: 1 });
				} catch (ignore) {}

				if (test.length === 1) {
					// ES6
					desc = { configurable: true, writable: false, enumerable: false };
					defineProperty = Object.defineProperty;
					module.exports = function (fn, length) {
						length = toPosInt(length);
						if (fn.length === length) return fn;
						desc.value = length;
						return defineProperty(fn, 'length', desc);
					};
				} else {
					mixin = require('../object/mixin');
					generate = (function () {
						var cache = [];
						return function (l) {
							var args, i = 0;
							if (cache[l]) return cache[l];
							args = [];
							while (l--) args.push('a' + (++i).toString(36));
							return new Function('fn', 'return function (' + args.join(', ') +
								') { return fn.apply(this, arguments); };');
						};
					}());
					module.exports = function (src, length) {
						var target;
						length = toPosInt(length);
						if (src.length === length) return src;
						target = generate(length)(src);
						try { mixin(target, src); } catch (ignore) {}
						return target;
					};
				}
			},
			"is-arguments.js": function (exports, module, require) {
				'use strict';

				var toString = Object.prototype.toString

				  , id = toString.call((function () { return arguments; }()));

				module.exports = function (x) { return (toString.call(x) === id); };
			},
			"is-function.js": function (exports, module, require) {
				'use strict';

				var toString = Object.prototype.toString

				  , id = toString.call(require('./noop'));

				module.exports = function (f) {
					return (typeof f === "function") && (toString.call(f) === id);
				};
			},
			"noop.js": function (exports, module, require) {
				'use strict';

				module.exports = function () {};
			}
		},
		"math": {
			"sign": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Math.sign
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						var sign = Math.sign;
						if (typeof sign !== 'function') return false;
						return ((sign(10) === 1) && (sign(-20) === -1));
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					module.exports = function (value) {
						value = Number(value);
						if (isNaN(value) || (value === 0)) return value;
						return (value > 0) ? 1 : -1;
					};
				}
			}
		},
		"number": {
			"to-integer.js": function (exports, module, require) {
				'use strict';

				var sign = require('../math/sign')

				  , abs = Math.abs, floor = Math.floor;

				module.exports = function (value) {
					if (isNaN(value)) return 0;
					value = Number(value);
					if ((value === 0) || !isFinite(value)) return value;
					return sign(value) * floor(abs(value));
				};
			},
			"to-pos-integer.js": function (exports, module, require) {
				'use strict';

				var toInteger = require('./to-integer')

				  , max = Math.max;

				module.exports = function (value) { return max(0, toInteger(value)); };
			}
		},
		"object": {
			"_iterate.js": function (exports, module, require) {
				// Internal method, used by iteration functions.
				// Calls a function for each key-value pair found in object
				// Optionally takes compareFn to iterate object in specific order

				'use strict';

				var isCallable = require('./is-callable')
				  , callable   = require('./valid-callable')
				  , value      = require('./valid-value')

				  , call = Function.prototype.call, keys = Object.keys
				  , propertyIsEnumerable = Object.prototype.propertyIsEnumerable;

				module.exports = function (method, defVal) {
					return function (obj, cb/*, thisArg, compareFn*/) {
						var list, thisArg = arguments[2], compareFn = arguments[3];
						obj = Object(value(obj));
						callable(cb);

						list = keys(obj);
						if (compareFn) {
							list.sort(isCallable(compareFn) ? compareFn.bind(obj) : undefined);
						}
						return list[method](function (key, index) {
							if (!propertyIsEnumerable.call(obj, key)) return defVal;
							return call.call(cb, thisArg, obj[key], key, obj, index);
						});
					};
				};
			},
			"assign": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Object.assign
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						var assign = Object.assign, obj;
						if (typeof assign !== 'function') return false;
						obj = { foo: 'raz' };
						assign(obj, { bar: 'dwa' }, { trzy: 'trzy' });
						return (obj.foo + obj.bar + obj.trzy) === 'razdwatrzy';
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var keys  = require('../keys')
					  , value = require('../valid-value')

					  , max = Math.max;

					module.exports = function (dest, src/*, …srcn*/) {
						var error, i, l = max(arguments.length, 2), assign;
						dest = Object(value(dest));
						assign = function (key) {
							try { dest[key] = src[key]; } catch (e) {
								if (!error) error = e;
							}
						};
						for (i = 1; i < l; ++i) {
							src = arguments[i];
							keys(src).forEach(assign);
						}
						if (error !== undefined) throw error;
						return dest;
					};
				}
			},
			"for-each.js": function (exports, module, require) {
				'use strict';

				module.exports = require('./_iterate')('forEach');
			},
			"is-callable.js": function (exports, module, require) {
				// Deprecated

				'use strict';

				module.exports = function (obj) { return typeof obj === 'function'; };
			},
			"is-object.js": function (exports, module, require) {
				'use strict';

				var map = { 'function': true, 'object': true };

				module.exports = function (x) {
					return ((x != null) && map[typeof x]) || false;
				};
			},
			"keys": {
				"index.js": function (exports, module, require) {
					'use strict';

					module.exports = require('./is-implemented')()
						? Object.keys
						: require('./shim');
				},
				"is-implemented.js": function (exports, module, require) {
					'use strict';

					module.exports = function () {
						try {
							Object.keys('primitive');
							return true;
						} catch (e) { return false; }
					};
				},
				"shim.js": function (exports, module, require) {
					'use strict';

					var keys = Object.keys;

					module.exports = function (object) {
						return keys(object == null ? object : Object(object));
					};
				}
			},
			"mixin.js": function (exports, module, require) {
				'use strict';

				var value = require('./valid-value')

				  , defineProperty = Object.defineProperty
				  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor
				  , getOwnPropertyNames = Object.getOwnPropertyNames;

				module.exports = function (target, source) {
					var error;
					target = Object(value(target));
					getOwnPropertyNames(Object(value(source))).forEach(function (name) {
						try {
							defineProperty(target, name, getOwnPropertyDescriptor(source, name));
						} catch (e) { error = e; }
					});
					if (error !== undefined) throw error;
					return target;
				};
			},
			"normalize-options.js": function (exports, module, require) {
				'use strict';

				var assign = require('./assign')

				  , forEach = Array.prototype.forEach
				  , create = Object.create, getPrototypeOf = Object.getPrototypeOf

				  , process;

				process = function (src, obj) {
					var proto = getPrototypeOf(src);
					return assign(proto ? process(proto, obj) : obj, src);
				};

				module.exports = function (options/*, …options*/) {
					var result = create(null);
					forEach.call(arguments, function (options) {
						if (options == null) return;
						process(Object(options), result);
					});
					return result;
				};
			},
			"valid-callable.js": function (exports, module, require) {
				'use strict';

				module.exports = function (fn) {
					if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
					return fn;
				};
			},
			"valid-object.js": function (exports, module, require) {
				'use strict';

				var isObject = require('./is-object');

				module.exports = function (value) {
					if (!isObject(value)) throw new TypeError(value + " is not an Object");
					return value;
				};
			},
			"valid-value.js": function (exports, module, require) {
				'use strict';

				module.exports = function (value) {
					if (value == null) throw new TypeError("Cannot use null or undefined");
					return value;
				};
			}
		},
		"string": {
			"#": {
				"contains": {
					"index.js": function (exports, module, require) {
						'use strict';

						module.exports = require('./is-implemented')()
							? String.prototype.contains
							: require('./shim');
					},
					"is-implemented.js": function (exports, module, require) {
						'use strict';

						var str = 'razdwatrzy';

						module.exports = function () {
							if (typeof str.contains !== 'function') return false;
							return ((str.contains('dwa') === true) && (str.contains('foo') === false));
						};
					},
					"shim.js": function (exports, module, require) {
						'use strict';

						var indexOf = String.prototype.indexOf;

						module.exports = function (searchString/*, position*/) {
							return indexOf.call(this, searchString, arguments[1]) > -1;
						};
					}
				},
				"pad.js": function (exports, module, require) {
					'use strict';

					var toInteger = require('../../number/to-integer')
					  , value     = require('../../object/valid-value')
					  , repeat    = require('./repeat')

					  , abs = Math.abs, max = Math.max;

					module.exports = function (fill/*, length*/) {
						var self = String(value(this))
						  , sLength = self.length
						  , length = arguments[1];

						length = isNaN(length) ? 1 : toInteger(length);
						fill = repeat.call(String(fill), abs(length));
						if (length >= 0) return fill.slice(0, max(0, length - sLength)) + self;
						return self + (((sLength + length) >= 0) ? '' : fill.slice(length + sLength));
					};
				},
				"repeat": {
					"index.js": function (exports, module, require) {
						'use strict';

						module.exports = require('./is-implemented')()
							? String.prototype.repeat
							: require('./shim');
					},
					"is-implemented.js": function (exports, module, require) {
						'use strict';

						var str = 'foo';

						module.exports = function () {
							if (typeof str.repeat !== 'function') return false;
							return (str.repeat(2) === 'foofoo');
						};
					},
					"shim.js": function (exports, module, require) {
						// Thanks: http://www.2ality.com/2014/01/efficient-string-repeat.html

						'use strict';

						var value     = require('../../../object/valid-value')
						  , toInteger = require('../../../number/to-integer');

						module.exports = function (count) {
							var str = String(value(this)), result;
							count = toInteger(count);
							if (count < 0) throw new RangeError("Count must be >= 0");
							if (!isFinite(count)) throw new RangeError("Count must be < ∞");
							result = '';
							if (!count) return result;
							while (true) {
								if (count & 1) result += str;
								count >>>= 1;
								if (count <= 0) break;
								str += str;
							}
							return result;
						};
					}
				}
			},
			"is-string.js": function (exports, module, require) {
				'use strict';

				var toString = Object.prototype.toString

				  , id = toString.call('');

				module.exports = function (x) {
					return (typeof x === 'string') || (x && (typeof x === 'object') &&
						((x instanceof String) || (toString.call(x) === id))) || false;
				};
			}
		}
	},
	"es6-symbol": {
		"index.js": function (exports, module, require) {
			'use strict';

			module.exports = require('./is-implemented')() ? Symbol : require('./polyfill');
		},
		"is-implemented.js": function (exports, module, require) {
			'use strict';

			module.exports = function () {
				var symbol;
				if (typeof Symbol !== 'function') return false;
				symbol = Symbol('test symbol');
				try { String(symbol); } catch (e) { return false; }
				if (typeof Symbol.iterator === 'symbol') return true;

				// Return 'true' for polyfills
				if (typeof Symbol.isConcatSpreadable !== 'object') return false;
				if (typeof Symbol.isRegExp !== 'object') return false;
				if (typeof Symbol.iterator !== 'object') return false;
				if (typeof Symbol.toPrimitive !== 'object') return false;
				if (typeof Symbol.toStringTag !== 'object') return false;
				if (typeof Symbol.unscopables !== 'object') return false;

				return true;
			};
		},
		"polyfill.js": function (exports, module, require) {
			'use strict';

			var d = require('d')

			  , create = Object.create, defineProperties = Object.defineProperties
			  , generateName, Symbol;

			generateName = (function () {
				var created = create(null);
				return function (desc) {
					var postfix = 0;
					while (created[desc + (postfix || '')]) ++postfix;
					desc += (postfix || '');
					created[desc] = true;
					return '@@' + desc;
				};
			}());

			module.exports = Symbol = function (description) {
				var symbol;
				if (this instanceof Symbol) {
					throw new TypeError('TypeError: Symbol is not a constructor');
				}
				symbol = create(Symbol.prototype);
				description = (description === undefined ? '' : String(description));
				return defineProperties(symbol, {
					__description__: d('', description),
					__name__: d('', generateName(description))
				});
			};

			Object.defineProperties(Symbol, {
				create: d('', Symbol('create')),
				hasInstance: d('', Symbol('hasInstance')),
				isConcatSpreadable: d('', Symbol('isConcatSpreadable')),
				isRegExp: d('', Symbol('isRegExp')),
				iterator: d('', Symbol('iterator')),
				toPrimitive: d('', Symbol('toPrimitive')),
				toStringTag: d('', Symbol('toStringTag')),
				unscopables: d('', Symbol('unscopables'))
			});

			defineProperties(Symbol.prototype, {
				properToString: d(function () {
					return 'Symbol (' + this.__description__ + ')';
				}),
				toString: d('', function () { return this.__name__; })
			});
			Object.defineProperty(Symbol.prototype, Symbol.toPrimitive, d('',
				function (hint) {
					throw new TypeError("Conversion of symbol objects is not allowed");
				}));
			Object.defineProperty(Symbol.prototype, Symbol.toStringTag, d('c', 'Symbol'));
		}
	},
	"event-emitter": {
		"index.js": function (exports, module, require) {
			'use strict';

			var d        = require('d')
			  , callable = require('es5-ext/object/valid-callable')

			  , apply = Function.prototype.apply, call = Function.prototype.call
			  , create = Object.create, defineProperty = Object.defineProperty
			  , defineProperties = Object.defineProperties
			  , hasOwnProperty = Object.prototype.hasOwnProperty
			  , descriptor = { configurable: true, enumerable: false, writable: true }

			  , on, once, off, emit, methods, descriptors, base;

			on = function (type, listener) {
				var data;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) {
					data = descriptor.value = create(null);
					defineProperty(this, '__ee__', descriptor);
					descriptor.value = null;
				} else {
					data = this.__ee__;
				}
				if (!data[type]) data[type] = listener;
				else if (typeof data[type] === 'object') data[type].push(listener);
				else data[type] = [data[type], listener];

				return this;
			};

			once = function (type, listener) {
				var once, self;

				callable(listener);
				self = this;
				on.call(this, type, once = function () {
					off.call(self, type, once);
					apply.call(listener, this, arguments);
				});

				once.__eeOnceListener__ = listener;
				return this;
			};

			off = function (type, listener) {
				var data, listeners, candidate, i;

				callable(listener);

				if (!hasOwnProperty.call(this, '__ee__')) return this;
				data = this.__ee__;
				if (!data[type]) return this;
				listeners = data[type];

				if (typeof listeners === 'object') {
					for (i = 0; (candidate = listeners[i]); ++i) {
						if ((candidate === listener) ||
								(candidate.__eeOnceListener__ === listener)) {
							if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
							else listeners.splice(i, 1);
						}
					}
				} else {
					if ((listeners === listener) ||
							(listeners.__eeOnceListener__ === listener)) {
						delete data[type];
					}
				}

				return this;
			};

			emit = function (type) {
				var i, l, listener, listeners, args;

				if (!hasOwnProperty.call(this, '__ee__')) return;
				listeners = this.__ee__[type];
				if (!listeners) return;

				if (typeof listeners === 'object') {
					l = arguments.length;
					args = new Array(l - 1);
					for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

					listeners = listeners.slice();
					for (i = 0; (listener = listeners[i]); ++i) {
						apply.call(listener, this, args);
					}
				} else {
					switch (arguments.length) {
					case 1:
						call.call(listeners, this);
						break;
					case 2:
						call.call(listeners, this, arguments[1]);
						break;
					case 3:
						call.call(listeners, this, arguments[1], arguments[2]);
						break;
					default:
						l = arguments.length;
						args = new Array(l - 1);
						for (i = 1; i < l; ++i) {
							args[i - 1] = arguments[i];
						}
						apply.call(listeners, this, args);
					}
				}
			};

			methods = {
				on: on,
				once: once,
				off: off,
				emit: emit
			};

			descriptors = {
				on: d(on),
				once: d(once),
				off: d(off),
				emit: d(emit)
			};

			base = defineProperties({}, descriptors);

			module.exports = exports = function (o) {
				return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
			};
			exports.methods = methods;
		},
		"unify.js": function (exports, module, require) {
			'use strict';

			var forEach    = require('es5-ext/object/for-each')
			  , validValue = require('es5-ext/object/valid-object')

			  , push = Array.prototype.apply, defineProperty = Object.defineProperty
			  , create = Object.create, hasOwnProperty = Object.prototype.hasOwnProperty
			  , d = { configurable: true, enumerable: false, writable: true };

			module.exports = function (e1, e2) {
				var data;
				(validValue(e1) && validValue(e2));
				if (!hasOwnProperty.call(e1, '__ee__')) {
					if (!hasOwnProperty.call(e2, '__ee__')) {
						d.value = create(null);
						defineProperty(e1, '__ee__', d);
						defineProperty(e2, '__ee__', d);
						d.value = null;
						return;
					}
					d.value = e2.__ee__;
					defineProperty(e1, '__ee__', d);
					d.value = null;
					return;
				}
				data = d.value = e1.__ee__;
				if (!hasOwnProperty.call(e2, '__ee__')) {
					defineProperty(e2, '__ee__', d);
					d.value = null;
					return;
				}
				if (data === e2.__ee__) return;
				forEach(e2.__ee__, function (listener, name) {
					if (!data[name]) {
						data[name] = listener;
						return;
					}
					if (typeof data[name] === 'object') {
						if (typeof listener === 'object') push.apply(data[name], listener);
						else data[name].push(listener);
					} else if (typeof listener === 'object') {
						listener.unshift(data[name]);
						data[name] = listener;
					} else {
						data[name] = [data[name], listener];
					}
				});
				defineProperty(e2, '__ee__', d);
				d.value = null;
			};
		}
	},
	"next-tick": {
		"index.js": function (exports, module, require) {
			'use strict';

			var callable, byObserver;

			callable = function (fn) {
				if (typeof fn !== 'function') throw new TypeError(fn + " is not a function");
				return fn;
			};

			byObserver = function (Observer) {
				var node = document.createTextNode(''), queue, i = 0;
				new Observer(function () {
					var data;
					if (!queue) return;
					data = queue;
					queue = null;
					if (typeof data === 'function') {
						data();
						return;
					}
					data.forEach(function (fn) { fn(); });
				}).observe(node, { characterData: true });
				return function (fn) {
					callable(fn);
					if (queue) {
						if (typeof queue === 'function') queue = [queue, fn];
						else queue.push(fn);
						return;
					}
					queue = fn;
					node.data = (i = ++i % 2);
				};
			};

			module.exports = (function () {
				// Node.js
				if ((typeof process !== 'undefined') && process &&
						(typeof process.nextTick === 'function')) {
					return process.nextTick;
				}

				// MutationObserver=
				if ((typeof document === 'object') && document) {
					if (typeof MutationObserver === 'function') {
						return byObserver(MutationObserver);
					}
					if (typeof WebKitMutationObserver === 'function') {
						return byObserver(WebKitMutationObserver);
					}
				}

				// W3C Draft
				// http://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html
				if (typeof setImmediate === 'function') {
					return function (cb) { setImmediate(callable(cb)); };
				}

				// Wide available standard
				if (typeof setTimeout === 'function') {
					return function (cb) { setTimeout(callable(cb), 0); };
				}

				return null;
			}());
		}
	}
})("deferred/index");
